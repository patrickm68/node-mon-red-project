/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

const clone = require("clone");
const Flow = require('./Flow').Flow;

const redUtil = require("@node-red/util").util;
const flowUtil = require("./util");

var Log;


class Subflow extends Flow {
    constructor(parent,globalFlow,subflowDef,subflowInstance) {
        // console.log(subflowDef);
        // console.log("CREATE SUBFLOW",subflowDef.id,subflowInstance.id);
        // console.log("SubflowInstance\n"+JSON.stringify(subflowInstance," ",2));
        // console.log("SubflowDef\n"+JSON.stringify(subflowDef," ",2));
        var subflows = parent.flow.subflows;
        var globalSubflows = parent.global.subflows;

        var node_map = {};
        var node;
        var wires;
        var i;

        var subflowInternalFlowConfig = {
            id: subflowInstance.id,
            configs: {},
            nodes: {},
            subflows: {}
        }

        if (subflowDef.configs) {
            // Clone all of the subflow config node definitions and give them new IDs
            for (i in subflowDef.configs) {
                if (subflowDef.configs.hasOwnProperty(i)) {
                    node = createNodeInSubflow(subflowInstance.id,subflowDef.configs[i]);
                    node_map[node._alias] = node;
                    subflowInternalFlowConfig.configs[node.id] = node;
                }
            }
        }
        if (subflowDef.nodes) {
            // Clone all of the subflow node definitions and give them new IDs
            for (i in subflowDef.nodes) {
                if (subflowDef.nodes.hasOwnProperty(i)) {
                    node = createNodeInSubflow(subflowInstance.id,subflowDef.nodes[i]);
                    node_map[node._alias] = node;
                    subflowInternalFlowConfig.nodes[node.id] = node;
                }
            }
        }

        subflowInternalFlowConfig.subflows = clone(subflowDef.subflows || {});

        remapSubflowNodes(subflowInternalFlowConfig.configs,node_map);
        remapSubflowNodes(subflowInternalFlowConfig.nodes,node_map);

        // console.log("Instance config\n",JSON.stringify(subflowInternalFlowConfig,"",2));

        super(parent,globalFlow,subflowInternalFlowConfig);

        this.TYPE = 'subflow';
        this.subflowDef = subflowDef;
        this.subflowInstance = subflowInstance;
        this.node_map = node_map;
    }

    start(diff) {
        var self = this;
        // Create a subflow node to accept inbound messages and route appropriately
        var Node = require("../Node");
        var subflowInstanceConfig = {
            id: this.subflowInstance.id,
            type: this.subflowInstance.type,
            z: this.subflowInstance.z,
            name: this.subflowInstance.name,
            wires: [],
            _flow: this
        }
        if (this.subflowDef.in) {
            subflowInstanceConfig.wires = this.subflowDef.in.map(function(n) { return n.wires.map(function(w) { return self.node_map[w.id].id;})})
            subflowInstanceConfig._originalWires = clone(subflowInstanceConfig.wires);
        }

        this.node = new Node(subflowInstanceConfig);
        this.node.on("input", function(msg) { this.send(msg);});

        this.node._updateWires = this.node.updateWires;

        this.node.updateWires = function(newWires) {
            // Wire the subflow outputs
            if (self.subflowDef.out) {
                var node,wires,i,j;
                // Restore the original wiring to the internal nodes
                subflowInstanceConfig.wires = clone(subflowInstanceConfig._originalWires);
                for (i=0;i<self.subflowDef.out.length;i++) {
                    wires = self.subflowDef.out[i].wires;
                    for (j=0;j<wires.length;j++) {
                        if (wires[j].id != self.subflowDef.id) {
                            node = self.node_map[wires[j].id];
                            if (node._originalWires) {
                                node.wires = clone(node._originalWires);
                            }
                        }
                    }
                }

                var modifiedNodes = {};
                var subflowInstanceModified = false;
                for (i=0;i<self.subflowDef.out.length;i++) {
                    wires = self.subflowDef.out[i].wires;
                    for (j=0;j<wires.length;j++) {
                        if (wires[j].id === self.subflowDef.id) {
                            subflowInstanceConfig.wires[wires[j].port] = subflowInstanceConfig.wires[wires[j].port].concat(newWires[i]);
                            subflowInstanceModified = true;
                        } else {
                            node = self.node_map[wires[j].id];
                            node.wires[wires[j].port] = node.wires[wires[j].port].concat(newWires[i]);
                            modifiedNodes[node.id] = node;
                        }
                    }
                }
                Object.keys(modifiedNodes).forEach(function(id) {
                    var node = modifiedNodes[id];
                    self.activeNodes[id].updateWires(node.wires);
                });

                if (subflowInstanceModified) {
                    self.node._updateWires(subflowInstanceConfig.wires);
                }
            }
        }

        // Wire the subflow outputs
        if (this.subflowDef.out) {
            var modifiedNodes = {};
            for (var i=0;i<this.subflowDef.out.length;i++) {
                // i: the output index
                // This is what this Output is wired to
                wires = this.subflowDef.out[i].wires;
                for (var j=0;j<wires.length;j++) {
                    if (wires[j].id === this.subflowDef.id) {
                        // A subflow input wired straight to a subflow output
                        subflowInstanceConfig.wires[wires[j].port] = subflowInstanceConfig.wires[wires[j].port].concat(this.subflowInstance.wires[i])
                        this.node._updateWires(subflowInstanceConfig.wires);
                    } else {
                        var node = self.node_map[wires[j].id];
                        modifiedNodes[node.id] = node;
                        if (!node._originalWires) {
                            node._originalWires = clone(node.wires);
                        }
                        node.wires[wires[j].port] = (node.wires[wires[j].port]||[]).concat(this.subflowInstance.wires[i]);
                    }
                }
            }
        }

        super.start(diff);
    }

    stop(stopList,removedList) {
        return super.stop(stopList,removedList);
    }
}



function createNodeInSubflow(subflowInstanceId, def) {
    let node = clone(def);
    let nid = redUtil.generateId();
    // console.log("Create Node In subflow",node.id, "--->",nid, "(",node.type,")")
    // node_map[node.id] = node;
    node._alias = node.id;
    node.id = nid;
    node.z = subflowInstanceId;
    return node;
}


/**
 * Given an object of {id:nodes} and a map of {old-id:node}, modifiy all
 * properties in the nodes object to reference the new node ids.
 * This handles:
 *  - node.wires,
 *  - node.scope of Catch and Status nodes,
 *  - node.XYZ for any property where XYZ is recognised as an old property
 * @param  {[type]} nodes   [description]
 * @param  {[type]} nodeMap [description]
 * @return {[type]}         [description]
 */
function remapSubflowNodes(nodes,nodeMap) {
    for (var id in nodes) {
        if (nodes.hasOwnProperty(id)) {
            var node = nodes[id];
            if (node.wires) {
                var outputs = node.wires;
                for (j=0;j<outputs.length;j++) {
                    wires = outputs[j];
                    for (k=0;k<wires.length;k++) {
                        outputs[j][k] = nodeMap[outputs[j][k]].id
                    }
                }
            }
            if ((node.type === 'catch' || node.type === 'status') && node.scope) {
                node.scope = node.scope.map(function(id) {
                    return nodeMap[id]?nodeMap[id].id:""
                })
            } else {
                for (var prop in node) {
                    if (node.hasOwnProperty(prop) && prop !== '_alias') {
                        if (nodeMap[node[prop]]) {
                            //console.log("Mapped",node.type,node.id,prop,nodeMap[node[prop]].id);
                            node[prop] = nodeMap[node[prop]].id;
                        }
                    }
                }
            }
        }
    }
}

function createSubflow(parent,globalFlow,subflowDef,subflowInstance) {
    return new Subflow(parent,globalFlow,subflowDef,subflowInstance)
}

module.exports = {
    init: function(runtime) {
        Log = runtime.log;
    },
    create: createSubflow
}
