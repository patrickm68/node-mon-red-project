
/**
 * @mixin @node-red/diagnostics
 * @namespace RED.runtime.diagnostics
 */

var runtime;

var util = require("@node-red/util").util;

function buildDiagnosticReport(scope, callback) {
    var basic = {
        "report": "diagnostics",
        "scope": scope,
        "runtime": {
            version: runtime.settings.version,
            isStarted: runtime.isStarted()
        },
        settings: {
            available: runtime.settings.available(),
            apiMaxLength: runtime.settings.apiMaxLength || "NO SETTING",
            coreNodesDir: runtime.settings.coreNodesDir,
            contextStorage: listContextModules(),
            debugMaxLength: runtime.settings.debugMaxLength,
            editorTheme: runtime.settings.editorTheme,
            flowFile: runtime.settings.flowFile,
            disableEditor:runtime.settings.disableEditor,
            debugMaxLength:runtime.settings.debugMaxLength,
            
            httpAdminRoot: runtime.settings.httpAdminRoot,
            httpAdminCors: runtime.settings.httpAdminCors ? "HAS SETTING": "NOT SET",
            httpNodeAuth: runtime.settings.httpNodeAuth ? "HAS SETTING": "NOT SET", 
            
            httpNodeRoot: runtime.settings.httpNodeRoot,
            httpNodeCors: runtime.settings.httpNodeCors ? "HAS SETTING": "NOT SET",

            httpStatic: runtime.settings.httpStatic,
            httpStaticCors: runtime.settings.httpStaticCors,

            mqttReconnectTime: runtime.settings.mqttReconnectTime,


            uiHost: runtime.settings.uiHost ? "HAS SETTING": "NOT SET",
            uiPort: runtime.settings.uiPort ? "HAS SETTING": "NOT SET",
            userDir: runtime.settings.userDir ? "HAS SETTING": "NOT SET",

            version: runtime.settings.version
        }
    }
    var admin = {};
    if(scope == "admin") {
        admin = {
            httpAdminCors: runtime.settings.httpAdminCors ? runtime.settings.httpAdminCors : "NOT SET",
            httpNodeCors: runtime.settings.httpNodeCors ? runtime.settings.httpNodeCors : "NOT SET",
            uiHost: runtime.settings.uiHost ? runtime.settings.uiHost : "NOT SET",
            uiPort: runtime.settings.uiPort ? runtime.settings.uiPort : "NOT SET",
            userDir: runtime.settings.userDir ? runtime.settings.userDir : "NOT SET",
        }
    }

    var report = Object.assign({}, admin, basic);

    callback(report);

    function listContextModules() {
        var keys = Object.keys(runtime.settings.contextStorage);
        var result = {};
        keys.forEach(e => {
            result[e] = {
                module: runtime.settings.contextStorage[e].module
            }
        })
        return result;
    }
}


var api = module.exports = {
    init: function (_runtime) {
        runtime = _runtime;
    },
    /**
    * Gets the node-red diagnostics report
    * @param {{scope: string}} - settings
    * @return {Promise} - the diagnostics information
    * @memberof @node-red/diagnostics
    */
    get: async function (opts) {
        return new Promise(function (resolve, reject) {
            opts = opts || {}
            var scope = opts.scope;
            try {
                if (scope === 'admin') {
                    //admin level info
                    runtime.log.audit({ event: "diagnostics.get", scope: "admin" }, opts.req);
                    buildDiagnosticReport(scope, (report) => resolve(report));
                } else if (scope === 'detail') {
                    //detail!
                    runtime.log.audit({ event: "diagnostics.get", scope: "detail" }, opts.req);
                    buildDiagnosticReport(scope, (report) => resolve(report));
                } else if (scope === 'basic')  {
                    //basic!
                    runtime.log.audit({ event: "diagnostics.get", scope: "basic" }, opts.req);
                    buildDiagnosticReport(scope, (report) => resolve(report));   
                
                } else {
                    runtime.log.audit({ event: "diagnostics.get", scope: scope }, opts.req);
                    resolve({});
                }
            } catch (error) {
                runtime.log.audit({ event: "diagnostics.get", scope: scope }, opts.req);
                reject(error);
            }
        })
    },
}
