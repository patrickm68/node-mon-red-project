/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/**
 * @typedef LinkTarget
 * @type {object}
 * @property {string} id - ID of the target node.
 * @property {string} name - Name of target Node
 * @property {number} flowId - ID of flow where the target node exists
 * @property {string} flowName - Name of flow where the target node exists
 */


module.exports = function(RED) {
    "use strict";
    const crypto = require("crypto");
    const targetCache = (function() {
        const registry = { ids: {}, named: {}};
        function getIndex(/** @type {[LinkTarget]}*/ targets, id) {
            for (let index = 0; index < (targets || []).length; index++) {
                const element = targets[index];
                if (element.id === id) {
                    return index;
                }
            }
            return -1;
        }
        /**
         * Generate a target object from a node
         * @param {LinkInNode} node 
         * @returns {LinkTarget} a link target object
         */
        function generateTarget(node) {
            return {
                id: node.id, 
                name: node.name || node.id, 
                flowId: node._flow.flow.id,
                flowName: node._flow.flow.label,
                isSubFlow: false
            }
        }
        return {
            /**
             * Get a list of targets registerd to this name
             * @param {string} name 
             * @returns {[LinkTarget]} Targets registerd to this name.
             */
            getTargets(name) {
                return registry.named[name] || [];
            },
            /**
             * Get a single target by registered name.
             * To restrict to a single flow, include the `flowId`
             * If there is no targets OR more than one target, null is returned
             * @param {string} name Name of the node
             * @param {string} [flowId] 
             * @returns {LinkTarget} target
             */
             getTarget(name, flowId) {
                let possibleTargets = this.getTargets(name);
                /** @type {LinkTarget}*/ let target;
                if(possibleTargets.length) {
                    if(flowId) {
                        possibleTargets = possibleTargets.filter(e => e.flowId == flowId);
                    }
                }
                if(possibleTargets.length === 1) {
                    target = possibleTargets[0];
                } 
                return target;
            },
            /**
             * Get a target by node ID
             * @param {string} nodeId ID of the node
             * @returns {LinkTarget} target
             */
            getTargetById(nodeId) {
                return registry.ids[nodeId];
            },            
            register(/** @type {LinkInNode} */ node) {
                const target = generateTarget(node);
                const tByName = this.getTarget(target.name, target.flowId);
                if(!tByName) {
                    registry.named[target.name] = registry.named[target.name] || [];
                    registry.named[target.name].push(target)
                }
                registry.ids[target.id] = target;
                return target;
            },
            remove(node) {
                const target = generateTarget(node);
                const tn = this.getTarget(target.name, target.flowId);
                if(tn) {
                    const targs = this.getTargets(tn.name);
                    const idx = getIndex(targs, tn.id);
                    if(idx > -1) {
                        targs.splice(idx,1);
                    }
                }
                delete registry.ids[target.id];
            },
            clear() {
                registry = { ids: {}, named: {}};
            }
        }
    })();

    function LinkInNode(n) {
        RED.nodes.createNode(this,n);
        var node = this;
        var event = "node:"+n.id;
        var handler = function(msg) {
            msg._event = n.event;
            node.receive(msg);
        }
        targetCache.register(node);
        RED.events.on(event,handler);
        this.on("input", function(msg, send, done) {
            send(msg);
            done();
        });
        this.on("close",function() {
            targetCache.remove(node);
            RED.events.removeListener(event,handler);
        });
    }

    RED.nodes.registerType("link in",LinkInNode);

    function LinkOutNode(n) {
        RED.nodes.createNode(this,n);
        var node = this;
        var mode = n.mode || "link";

        var event = "node:"+n.id;
        this.on("input", function(msg, send, done) {
            msg._event = event;
            RED.events.emit(event,msg)

            if (mode === "return") {
                if (Array.isArray(msg._linkSource) && msg._linkSource.length > 0) {
                    var messageEvent = msg._linkSource.pop();
                    var returnNode = RED.nodes.getNode(messageEvent.node);
                    if (returnNode && returnNode.returnLinkMessage) {
                        returnNode.returnLinkMessage(messageEvent.id, msg);
                    } else {
                        node.warn(RED._("link.error.missingReturn"))
                    }
                } else {
                    node.warn(RED._("link.error.missingReturn"))
                }
                done();
            } else if (mode === "link") {
                send(msg);
                done();
            }
        });
    }
    RED.nodes.registerType("link out",LinkOutNode);


    function LinkCallNode(n) {
        RED.nodes.createNode(this,n);
        const node = this;
        const staticTarget = n.links[0];
        const linkType = n.linkType;
        const messageEvents = {};

        let timeout = parseFloat(n.timeout || "30") * 1000;
        if (isNaN(timeout)) {
            timeout = 30000;
        }
        function findNode(target) {
            let foundNode = RED.nodes.getNode(target); //1st see if the target is a direct node id
            if(!foundNode) {
                //first look in this flow for the node
                let cachedTarget = targetCache.getTarget(target, node._flow.flow.id);
                if(!cachedTarget) {
                    //single target node not found in registry! get all possible targets
                    const possibleTargets = targetCache.getTargets(target);
                    if(possibleTargets.length === 1) {
                        cachedTarget = possibleTargets[0];
                    } else if (possibleTargets.length > 1) {
                        throw new Error(`Multiple link-in nodes named '${target}' found`);
                    }
                }
                if (cachedTarget) {
                    foundNode = RED.nodes.getNode(cachedTarget.id);
                }
            }
            if(foundNode instanceof LinkInNode) {
                return foundNode;
            }
            throw new Error(`link-in node '${target}' not found`);
        }
        this.on("input", function(msg, send, done) {
            try {
                let targetNode = linkType == "dynamic" ? findNode(msg.target) : RED.nodes.getNode(staticTarget);
                if (targetNode && targetNode instanceof LinkInNode) {
                    msg._linkSource = msg._linkSource || [];
                    const messageEvent = {
                        id: crypto.randomBytes(14).toString('hex'),
                        node: node.id,
                    }        
                    messageEvents[messageEvent.id] = {
                        msg: RED.util.cloneMessage(msg),
                        send,
                        done,
                        ts: setTimeout(function() {
                            timeoutMessage(messageEvent.id)
                        }, timeout )
                    };
                    msg._linkSource.push(messageEvent);
                    targetNode.receive(msg);
                }  
            } catch (error) {
                node.error(error, msg);
            }
        });

        this.returnLinkMessage = function(eventId, msg) {
            if (Array.isArray(msg._linkSource) && msg._linkSource.length === 0) {
                delete msg._linkSource;
            }
            const messageEvent = messageEvents[eventId];
            if (messageEvent) {
                clearTimeout(messageEvent.ts);
                delete messageEvents[eventId];
                messageEvent.send(msg);
                messageEvent.done();
            } else {
                node.send(msg);
            }
        }

        function timeoutMessage(eventId) {
            const messageEvent = messageEvents[eventId];
            if (messageEvent) {
                delete messageEvents[eventId];
                node.error("timeout",messageEvent.msg);
            }
        }

    }
    RED.nodes.registerType("link call",LinkCallNode);


}
