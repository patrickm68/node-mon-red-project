{
    "common": {
        "label": {
            "payload": "Nutzdaten (Payload)",
            "topic": "Topic",
            "name": "Name",
            "username": "Benutzername",
            "password": "Passwort",
            "property": "Eigenschaft",
            "selectNodes": "Nodes auswählen ...",
            "expand": "Erweitern"
        },
        "status": {
            "connected": "Verbunden",
            "not-connected": "Nicht verbunden ",
            "disconnected": "Verbindung getrennt",
            "connecting": "Verbindung wird hergestellt",
            "error": "Fehler",
            "ok": "OK"
        },
        "notification": {
            "error": "<strong>Fehler:</strong> __message__",
            "errors": {
                "not-deployed": "Node nicht vorhanden",
                "no-response": "Keine Antwort vom Server",
                "unexpected": "Unerwarteter Fehler (__status__) __message__"
            }
        },
        "errors": {
            "nooverride": "Warnung: Nachrichten-Eigenschaften können die Eigenschaften des festgelegten Nodes nicht mehr außer Kraft setzen. Siehe Bit.ly/nr-override-msg-props"
        }
      }
    }
  },
  "trigger" : {
    "send" : "Senden",
    "then" : "dann",
    "then-send" : "dann senden",
    "output" : {
      "string" : "die Zeichenfolge",
      "number" : "die Zahl",
      "existing" : "das vorhandene Nachrichtenobjekt",
      "original" : "das ursprüngliche Nachrichtenobjekt",
      "latest" : "das neueste Nachrichtenobjekt",
      "nothing" : "nichts"
    },
    "wait-reset" : "warten auf Zurücksetzen",
    "wait-for" : "warten auf",
    "wait-loop" : "erneut senden aller",
    "for" : "Handhabung",
    "bytopics" : "für jeden <code>msg.topic</code> Wert unabhängig",
    "alltopics" : "alle Nachrichten",
    "duration" : {
      "ms" : "Millisek.",
      "s" : "Sekunden",
      "m" : "Minuten",
      "h" : "Stunden"
    },
    "extend" : " Verlängerung der Verzögerung bei Eingang neuer Nachricht",
    "label" : {
      "trigger" : "Auslöser",
      "trigger-block" : "Auslöser & Block",
      "trigger-loop" : "alle erneut senden",
      "reset" : "Setzen Sie den Auslöser zurück, wenn:",
      "resetMessage" : "msg.reset gesetzt ist oder ",
      "resetPayload" : "msg.payload ist gleich" ,
      "resetprompt" : "optional"
    }
  },
  "comment" : {
    "comment" : "Kommentar"
  },
  "unknown" : {
    "label" : {
      "unknown" : "unbekannt"
    },
    "tip" : "<p> Dieser Node ist ein Typ, der Ihrer Installation von Node-RED unbekannt ist. </p> <p> <i> Wenn Sie mit dem Node in diesem Status deployen, wird die Konfiguration beibehalten, aber der Fluss wird erst gestartet, wenn der fehlende Typ installiert ist. </i> </p> <p> Weitere Informationen finden Sie in der Info-Seitenleiste für. Weitere Hilfe </p>"
  },
  "mqtt" : {
    "label" : {
      "broker" : "Server",
      "example" : "z. B. lokaler_Host",
      "qos" : "QoS",
      "retain" : "Retain",
      "clientid" : "Client-ID",
      "port" : "Port",
      "keepalive" : "Keepalive-Zeit (en)",
      "cleansession" : "Bereinigte Sitzung verwenden",
      "use-tls" : "Sichere Verbindung (SSL/TLS) aktivieren",
      "tls-config" : "TLS-Konfiguration",
      "verify-server-cert" : "Serverzertifikat überprüfen",
      "compatmode" : "Traditionelle MQTT 3.1-Unterstützung verwenden"
    },
    "sections-label" : {
      "birth-message" : "Nachricht über Verbindungsaufbau ",
      "will-message" : "Nachricht über unerwarteten Abschaltung",
      "close-message" : "Nachricht bevor die Verbindung beendet wird"
    },
    "tabs-label" : {
      "connection" : "Verbindung",
      "security" : "Sicherheit",
      "messages" : "Nachrichten"
    },
    "placeholder" : {
      "clientid" : "Leerer Wert für automatische Generierung",
      "clientid-nonclean" : "Muss für nicht bereinigte Sitzungen festgelegt werden.",
      "will-topic" : "inaktivieren wenn leer",
      "birth-topic" : "inaktivieren wenn leer",
      "close-topic" : "inaktivieren wenn leer"
    },
    "state" : {
      "connected" : "Verbindung zum Broker __broker__ hergestellt.",
      "disconnected" : "Verbindung zum Broker  __broker__ wurde beendet.",
      "connect-failed" : "Verbindung zum Broker __broker__ konnte nicht hergestellt werden."
    },
    "retain" : "Retain",
    "true" : "Wahr",
    "false" : "Falsch",
    "tip" : "Tipp: Behalten Sie das Topic \"Artikel\", \"qos\" oder \"retain\" bei, wenn Sie diese über die Eigenschaft \"msg\" festlegen",
    "errors" : {
      "not-defined" : "Topic nicht definiert",
      "missing-config" : "Fehlende Brokerkonfiguration",
      "invalid-topic" : "Ungültiges Topic angegeben",
      "nonclean-missingclientid" : "Keine Client-ID-Gruppe unter Verwendung einer bereinigten Sitzung"
    }
  },
  "httpin" : {
    "label" : {
      "method" : "Methode",
      "url" : "URL",
      "doc" : "Docs",
      "return" : "Rückgabe",
      "upload" : "Dateiuploads akzeptieren?",
      "status" : "Statuscode",
      "headers" : "Kopfzeilen",
      "other" : "andere"
    },
    "setby" : "-durch msg.method festgelegt-",
    "basicauth" : "Basisauthentifizierung verwenden",
    "use-tls" : "Sichere Verbindung (SSL/TLS) aktivieren",
    "tls-config" : "TLS-Konfiguration",
    "utf8" : "eine UTF-8-Zeichenfolge",
    "binary" : "einen binären Buffer",
    "json" : "ein analysiertes JSON-Objekt",
    "tip" : {
      "in" : "Die URL ist relativ zu ",
      "res" : "Die an diesen Node gesendeten Nachrichten  <b> müssen </b>  von einem  <i> http-Input </i>  -Node stammen",
      "req" : "Tipp: Wenn die JSON-Syntaxanalyse fehlschlägt, wird die abgerufene Zeichenfolge als-ist zurückgegeben."
    },
    "httpreq" : "HTTP-Anforderung",
    "errors" : {
      "not-created" : "http-in-Node kann nicht erstellt werden, wenn httpNodeRoot auf 'false' gesetzt ist.",
      "missing-path" : "Fehlendes Pfad",
      "no-response" : "Kein Antwortobjekt",
      "json-error" : "JSON-Parsing-Fehler",
      "no-url" : "Keine URL angegeben",
      "deprecated-call" : "Nicht weiter unterstützter Aufruf von __method__",
      "invalid-transport" : "Nicht-http-Transport angefordert"
    },
    "status" : {
      "requesting" : "anfordern"
    }
  },
  "websocket" : {
    "label" : {
      "type" : "Typ",
      "path" : "Pfad",
      "url" : "URL"
    },
    "listenon" : "Empfangsbereit",
    "connectto" : "Verbinden mit",
    "sendrec" : "Senden/Empfangen",
    "payload" : "Nutzdaten",
    "message" : "gesamte Nachricht",
    "tip" : {
      "path1" : "Standardmäßig enthält  <code> Nutzdaten </code>  die Daten, die über einen Websocket gesendet oder von einem Websocket empfangen werden. Der Listener kann so konfiguriert werden, dass er das gesamte Nachrichtenobjekt als eine JSON-formatierte Zeichenfolge sendet oder empfängt.",
      "path2" : "Dieser Pfad ist relativ zu <code>__path__</code>.",
      "url1" : "URL sollte ws: &#47; & #47; oder wss: &#47; & #47; Schema verwenden und auf einen vorhandenen Websocket-Listener verweisen.",
      "url2" : "Standardmäßig enthält  <code> Nutzdaten </code>  die Daten, die über einen Websocket gesendet oder von einem Websocket empfangen werden. Der Client kann so konfiguriert werden, dass er das gesamte Nachrichtenobjekt als eine JSON-formatierte Zeichenfolge sendet oder empfängt."
    },
    "status" : {
      "connected" : "verbunden __count__",
      "connected_plural" : "verbunden __count__"
    },
    "errors" : {
      "connect-error" : "Bei der WS-Verbindung ist ein Fehler aufgetreten: ",
      "send-error" : "Beim Senden ist ein Fehler aufgetreten: ",
      "missing-conf" : "Fehlende Serverkonfiguration"
    }
  },
  "watch" : {
    "watch" : "Überwachung",
    "label" : {
      "files" : "Datei (en)",
      "recursive" : "Unterverzeichnisse rekursiv überwachen"
    },
    "placeholder" : {
      "files" : "Durch Komma getrennte Liste von Dateien und/oder Verzeichnissen"
    },
    "tip" : "Unter Windows müssen Sie doppelte Backslashes \\\\ in beliebigen Verzeichnisnamen verwenden."
  },
  "tcpin" : {
    "label" : {
      "type" : "Typ",
      "output" : "Ausgabe",
      "port" : "Port",
      "host" : "auf Host",
      "payload" : "Payload (en)",
      "delimited" : "begrenzt durch",
      "close-connection" : "Schließen Sie die Verbindung, nachdem jede Nachricht gesendet wurde?",
      "decode-base64" : "Nachricht aus Base64 dekodierien?",
      "server" : "Server",
      "return" : "Rückgabe",
      "ms" : "ms",
      "chars" : "Chars"
    },
    "type" : {
      "listen" : "Empfangsbereit",
      "connect" : "Verbinden mit",
      "reply" : "Auf TCP antworten"
    },
    "output" : {
      "stream" : "Datenstrom von",
      "single" : "Single",
      "buffer" : "Buffer",
      "string" : "Zeichenfolge",
      "base64" : "Base64-Zeichenfolge"
    },
    "return" : {
      "timeout" : "nach einem festen Zeitlimit von",
      "character" : "wenn folgendes Zeichen empfangen wird",
      "number" : "eine festgelegte Anzahl von Zeichen",
      "never" : "keine Rückgabe - Verbindung wird offen gehalten",
      "immed" : "sofort - Wartet nicht auf Antwort."
    },
    "status" : {
      "connecting" : "Verbindung zu __host__: __port__",
      "connected" : "Verbindung zu __host__: __port__",
      "listening-port" : "empfangsbereit an Port __port__",
      "stopped-listening" : "Empfangsbereitschaft an Port gestoppt",
      "connection-from" : "Verbindung von __host__: __port__",
      "connection-closed" : "Verbindung geschlossen von __host__: __port__",
      "connections" : "__count__connection",
      "connections_plural" : "__count__connections"
    },
    "errors" : {
      "connection-lost" : "Verbindung verloren zu __host__: __port__",
      "timeout" : "Zeitlimit für geschlossenen Socket-Port __port__",
      "cannot-listen" : "Port __port__ kann nicht empfangsbereit sein. Fehler: __error__",
      "error" : "Fehler: __error__",
      "socket-error" : "Socketfehler von __host__: __port__",
      "no-host" : "Host und/oder Port nicht festgelegt",
      "connect-timeout" : "Verbindungszeitlimit",
      "connect-fail" : "Verbindung fehlgeschlagen"
    }
  },
  "udp" : {
    "label" : {
      "listen" : "Empfangsbereit",
      "onport" : "an Port",
      "using" : "verwenden",
      "output" : "Ausgabe",
      "group" : "Gruppe",
      "interface" : "Lokal IF",
      "send" : "Schicken Sie eine",
      "toport" : "an Port",
      "address" : "Adresse",
      "decode-base64" : "Dekodiere Base64-kodierte Nutzdaten?"
    },
    "placeholder" : {
      "interface" : "(optional) lokale Schnittstelle oder Adresse, an die gebunden werden soll",
      "interfaceprompt" : "(optional) lokale Schnittstelle oder Adresse, an die gebunden werden soll",
      "address" : "Ziel-IP"
    },
    "udpmsgs" : "udp-Nachrichten",
    "mcmsgs" : "Multicastnachrichten",
    "udpmsg" : "udp-Nachricht",
    "bcmsg" : "Broadcastnachricht",
    "mcmsg" : "Multicastnachricht",
    "output" : {
      "buffer" : "ein Buffer",
      "string" : "eine Zeichenfolge",
      "base64" : "Eine Base64-codierte Zeichenfolge"
    },
    "bind" : {
      "random" : "an zufälliger lokaler Port binden",
      "local" : "Bindung an lokalen Port",
      "target" : "Bindung an Zielport"
    },
    "tip" : {
      "in" : "Tipp: Stellen Sie sicher, dass Ihre Firewall die Daten in zulässt.",
      "out" : "Tipp: Lassen Sie die Adresse und den Port leer, wenn Sie mit  <code> msg.ip </code>  und  <code> msg.port </code> festlegen möchten.",
      "port" : "Ports, die bereits verwendet werden: "
    },
    "status" : {
      "listener-at" : "udp listener at __host__: __port__",
      "mc-group" : "udp Multicastgruppe __Gruppe__",
      "listener-stopped" : "udp-Listener gestoppt",
      "output-stopped" : "udp-Ausgabe gestoppt",
      "mc-ready" : "udp multicast ready: __iface__: __outport__-> __host__: __port__",
      "bc-ready" : "udp broadcast ready: __outport__-> __host__: __port__",
      "ready" : "udp ready: __outport__-> __host__: __port__",
      "ready-nolocal" : "udp bereit: __host__: __port__",
      "re-use" : "udp re-use socket: __outport__-> __host__: __port__"
    },
    "errors" : {
      "access-error" : "UDP-Zugriffsfehler, Sie benötigen möglicherweise Rootzugriff für Ports unter 1024",
      "error" : "Fehler: __error__",
      "bad-mcaddress" : "Ungültige Multicastadresse",
      "interface" : "Sie müssen die IP-Adresse der erforderlichen Schnittstelle sein.",
      "ip-notset" : "udp: ip-Adresse nicht festgelegt",
      "port-notset" : "udp: Port nicht festgelegt",
      "port-invalid" : "udp: Portnummer nicht gültig",
      "alreadyused" : "udp: Port __port__ wird bereits verwendet",
      "ifnotfound" : "udp: interface __iface__ nicht gefunden"
    }
  },
  "switch" : {
    "switch" : "Switch",
    "label" : {
      "property" : "Eigenschaft",
      "rule" : "Regel",
      "repair" : "Nachrichtenfolgen erneut erstellen"
    },
    "and" : "und",
    "checkall" : "Alle Regeln überprüfen",
    "stopfirst" : "Nach erster Übereinstimmung stoppen",
    "ignorecase" : "Groß-/Kleinschreibung ignorieren",
    "rules" : {
      "btwn" : "liegt zwischen",
      "cont" : "enthält",
      "regex" : "Übereinstimmungen mit regex",
      "true" : "ist wahr",
      "false" : "ist falsch",
      "null" : "ist null",
      "nnull" : "ist nicht null",
      "istype" : "ist vom Typ",
      "empty" : "ist leer",
      "nempty" : "ist nicht leer",
      "head" : "Header",
      "tail" : "Trailer",
      "index" : "Index zwischen",
      "exp" : "JSONata Ausdruck",
      "else" : "Andernfalls"
    },
    "errors" : {
      "invalid-expr" : "Ungültiger JSONata Ausdruck: __error__",
      "too-many" : "Zu viele anstehende Nachrichten im Switch-Node"
    }
  },
  "change" : {
    "label" : {
      "rules" : "Regeln",
      "rule" : "Regel",
      "set" : "setze __property__",
      "change" : "__property__ ändern",
      "delete" : "__property__ löschen",
      "move" : "bewege __property__",
      "changeCount" : "Ändern: __count__rules",
      "regex" : "Reguläre Ausdrücke verwenden"
    },
    "action" : {
      "set" : "Setze",
      "change" : "Ändern",
      "delete" : "Löschen",
      "move" : "Bewegen",
      "to" : "auf",
      "search" : "Suchen nach",
      "replace" : "Ersetzen durch"
    },
    "errors" : {
      "invalid-from" : "Ungültiges 'from' Merkmal: __error__",
      "invalid-json" : "Ungültiges 'to' JSON Merkmal",
      "invalid-expr" : "Ungültiger JSONata Ausdruck: __error__"
    }
  },
  "range" : {
    "range" : "Bereich",
    "label" : {
      "action" : "Aktion",
      "inputrange" : "von einem Eingabebereich",
      "resultrange" : "in einen Zielbereich",
      "from" : "von",
      "to" : "auf",
      "roundresult" : "Runde das Ergebnis auf die nächste ganze Zahl?"
    },
    "placeholder" : {
      "min" : "z. B. 0",
      "maxin" : "z. B. 99",
      "maxout" : "z. B. 255"
    },
    "scale" : {
      "payload" : "Skaliere die Nachrichteneigenschaft",
      "limit" : "Skalieren und Begrenzen auf den Zielbereich",
      "wrap" : "Skaliere und Einhüllen innerhalb des Zielbereichs"
    },
    "tip" : "Tipp: Dieser Node funktioniert NUR mit Zahlen.",
    "errors" : {
      "notnumber" : "Keine Zahl"
    }
  },
  "csv" : {
    "label" : {
      "columns" : "Spalten",
      "separator" : "Trennzeichen",
      "c2o" : "Optionen für CSV-zu-Objekt",
      "o2c" : "Objekt-zu-CSV-Optionen",
      "input" : "Eingabe",
      "skip-s" : "Zuerst überspringen",
      "skip-e" : "Zeilen",
      "firstrow" : "erste Zeile enthält Spaltennamen",
      "output" : "Ausgabe",
      "includerow" : "Spaltennamenszeile einschließen",
      "newline" : "Zeilenneuerzeile"
    },
    "placeholder" : {
      "columns" : "durch Kommas getrennte Spaltennamen"
    },
    "separator" : {
      "comma" : "Komma",
      "tab" : "Tabulatorzunge",
      "space" : "Leerzeichen",
      "semicolon" : "Semikolon",
      "colon" : "Doppelpunkt",
      "hashtag" : "hashtag",
      "other" : "andere ..."
    },
    "output" : {
      "row" : "eine Nachricht pro Zeile",
      "array" : "eine einzelne Nachricht [ Array]"
    },
    "newline" : {
      "linux" : "Linux (\\n)",
      "mac" : "Mac (\\r)",
      "windows" : "Windows (\\r \\n)"
    },
    "errors" : {
      "csv_js" : "Dieser Node verarbeitet nur CSV-Zeichenfolgen oder JS-Objekte.",
      "obj_csv" : "Es wurde keine Spaltenschablone für Objekt-> CSV angegeben."
    }
  },
  "html" : {
    "label" : {
      "select" : "Selektor",
      "output" : "Ausgabe",
      "in" : "in"
    },
    "output" : {
      "html" : "den HTML-Inhalt der Elemente",
      "text" : "nur der Textinhalt der Elemente",
      "attr" : "ein Objekt mit allen Attributen der Elemente"
    },
    "format" : {
      "single" : "als einzelne Nachricht mit einem Array",
      "multi" : "als mehrere Nachrichten, eine für jedes Element"
    }
  },
  "json" : {
    "errors" : {
      "dropped-object" : "Ignorierte Nicht-Objekt-Nutzdaten",
      "dropped" : "Ignorierter nicht unterstützter Nutzdatentyp",
      "dropped-error" : "Fehler beim Konvertieren der Nutzdaten",
      "schema-error" : "JSON-Schema-Fehler",
      "schema-error-compile" : "JSON-Schema-Fehler: Schema konnte nicht kompiliert werden"
    },
    "label" : {
      "o2j" : "Objekt zu JSON-Optionen",
      "pretty" : "JSON-Zeichenfolge formatieren",
      "action" : "Aktion",
      "property" : "Eigenschaft",
      "actions" : {
        "toggle" : "Konvertieren zwischen JSON-Zeichenfolge und Objekt",
        "str" : "Immer in JSON-Zeichenfolge konvertieren",
        "obj" : "Immer in JavaScript-Objekt konvertieren"
      }
    }
  },
  "yaml" : {
    "errors" : {
      "dropped-object" : "Ignorierte Nicht-Objekt-Nutzdaten",
      "dropped" : "Ignorierter nicht unterstützter Nutzdatentyp",
      "dropped-error" : "Fehler beim Konvertieren der Nutzdaten"
    }
  },
  "xml" : {
    "label" : {
      "represent" : "Eigenschaftsname für XML-Tagattribute",
      "prefix" : "Eigenschaftsname für Tagtextinhalt",
      "advanced" : "Erweiterte Optionen",
      "x2o" : "Optionen für XML zu Objekt"
    },
    "errors" : {
      "xml_js" : "Dieser Node verarbeitet nur XML-Zeichenfolgen oder JS-Objekte."
    }
  },
  "file" : {
    "label" : {
      "filename" : "Name der Datei",
      "action" : "Aktion",
      "addnewline" : "Neue Zeile (\\n) zu den einzelnen Nutzdaten hinzufügen?",
      "createdir" : "Verzeichnis erstellen, wenn es nicht vorhanden ist?",
      "outputas" : "Ausgabe",
      "breakchunks" : "In Chunks aufbrechen",
      "breaklines" : "In Linien aufbrechen",
      "filelabel" : "Datei",
      "sendError" : "Nachricht bei Fehler senden (traditioneller Modus)",
      "deletelabel" : "__file__ löschen"
    },
    "action" : {
      "append" : "an Datei anhängen",
      "overwrite" : "Datei überschreiben",
      "delete" : "Datei löschen"
    },
    "output" : {
      "utf8" : "eine einzelne utf8-Zeichenfolge",
      "buffer" : "ein einzelnes Bufferobjekt",
      "lines" : "ein Nachricht pro Zeile",
      "stream" : "ein Datenstrom von Buffers"
    },
    "status" : {
      "wrotefile" : "in Datei geschrieben: __file__",
      "deletedfile" : "gelöschte Datei: __file__",
      "appendedfile" : "an Datei angefügt: __file__"
    },
    "errors" : {
      "nofilename" : "Kein Dateiname angegeben",
      "invaliddelete" : "Warnung: Ungültiges Löschen. Bitte verwenden Sie im Konfigurationsdialog eine bestimmte Löschoption.",
      "deletefail" : "Fehler beim Löschen der Datei: __error__",
      "writefail" : "Schreiben in Datei fehlgeschlagen: __error__",
      "appendfail" : "Anhängen an Datei fehlgeschlagen: __error__",
      "createfail" : "Fehler beim Erstellen der Datei: __error__"
    },
    "tip" : "Tipp: Der Dateiname muss ein absoluter Pfad sein. Andernfalls wird er relativ zum Arbeitsverzeichnis des Node-RED-Prozesses verwendet."
  },
  "split" : {
    "split" : "aufteilen",
    "intro" : "Trennen Sie  <code> msg.payload </code>  basierend auf dem Typ:",
    "object" : "<b> Objekt </b>",
    "objectSend" : "Eine Nachricht für jedes Schlüssel/Wert-Paar senden",
    "strBuff" : "<b> Zeichenfolge </b> / <b> Buffer </b>",
    "array" : "<b> Array </b>",
    "splitUsing" : "Trennen mit",
    "splitLength" : "Feste Länge von",
    "stream" : "Behandeln als Strom von Nachrichten",
    "addname" : "Schlüssel kopieren nach "
  },
  "join" : {
    "join" : "Join",
    "mode" : {
      "mode" : "Modus",
      "auto" : "Automatisch",
      "merge" : "Sequenzen zusammenführen",
      "reduce" : "Reihenfolge bestimmen",
      "custom" : "Manuell"
    },
    "combine" : "Kombiniere alle",
    "create" : "und erstelle",
    "type" : {
      "string" : "eine Zeichenfolge",
      "array" : "ein Array",
      "buffer" : "ein Buffer",
      "object" : "ein Schlüssel/Wert-Objekt",
      "merged" : "ein zusammengefasstes Objekt"
    },
    "using" : "mit dem Wert von",
    "key" : "als Schlüssel",
    "joinedUsing" : "verbunden mit",
    "send" : "Senden Sie die Nachricht:",
    "afterCount" : "nach einer Reihe von Nachrichtenteilen",
    "count" : "Zähler",
    "subsequent" : "und jede nachfolgende Nachricht.",
    "afterTimeout" : "nach Zeitlimitüberschreitung von",
    "seconds" : "Sekunden",
    "complete" : "Nach einer Nachricht mit der gesetzten Eigenschaft <code>msg.complete</code>",
    "tip" : "Dieser Modus setzt voraus, dass dieser Node entweder mit einem  <i> split </i> Node verbunden ist oder dass die empfangenen Nachrichten über eine ordnungsgemäß konfigurierte Eigenschaft  <code> msg.parts </code>  verfügen.",
    "too-many" : "Zu viele anstehende Nachrichten im Verknüpfungs-Node",
    "merge" : {
      "topics-label" : "Zusammengemiedene Themen",
      "topics" : "Themen",
      "topic" : "Topic",
      "on-change" : "Zusammengefügte Nachricht bei Ankunft eines neuen Topics senden"
    },
    "reduce" : {
      "exp" : "Zusammenfassen durch",
      "exp-value" : "Ausdruck",
      "init" : "Anfangswert",
      "right" : "In umgekehrter Reihenfolge auswerten (letzter auf den ersten)",
      "fixup" : "Fix-up"
    },
    "errors" : {
      "invalid-expr" : "Ungültiger JSONata-Ausdruck: __error__"
=======
    },
    "inject": {
        "inject": "inject",
        "repeat": "Wiederholen = __repeat__",
        "crontab": "Crontab = __crontab__",
        "stopped": "Gestoppt",
        "failed": "Injizieren fehlgeschlagen: __error__",
        "label": {
            "properties": "Eigenschaften",
            "repeat": "Wiederholung",
            "flow": "Flow Kontext",
            "global": "Globaler Kontext",
            "str": "string",
            "num": "number",
            "bool": "boolean",
            "json": "object",
            "bin": "buffer",
            "date": "timestamp",
            "env": "Umgebungsvariable",
            "object": "object",
            "string": "string",
            "boolean": "boolean",
            "number": "number",
            "Array": "array",
            "invalid": "Üngültiges JSON-Objekt"
        },
        "timestamp": "timestamp",
        "none": "Keine",
        "interval": "Intervall",
        "interval-time": "Intervall zwischen Uhrzeiten",
        "time": "Täglicher Zeitpunkt",
        "seconds": "Sekunden",
        "minutes": "Minuten",
        "hours": "Stunden",
        "between": "zwischen",
        "previous": "vorheriger Wert",
        "at": "um",
        "and": "und",
        "every": "alle",
        "days": [
            "Montag",
            "Dienstag",
            "Mittwoch",
            "Donnerstag",
            "Freitag",
            "Samstag",
            "Sonntag"
        ],
        "on": "am",
        "onstart": "Einmal injizieren nach",
        "onceDelay": "Sekunden, danach",
        "success": "Erfolgreich injiziert: __label__",
        "errors": {
            "failed": "Injizieren fehlgeschlagen, siehe Protokoll für Details",
            "toolong": "Intervall zu groß",
            "invalid-expr": "Üngültiger JSONata-Ausdruck: __error__"
        }
    },
    "catch": {
        "catch": "catch: Alle",
        "catchNodes": "catch: __number__",
        "catchUncaught": "catch: Nicht gefangen",
        "label": {
            "source": "Fehler abfangen von",
            "selectAll": "Alles auswählen",
            "uncaught": "Fehler ignorieren, die von anderen <span style=\"background-color:Gainsboro\">catch</span>-Nodes behandelt wurden"
        },
        "scope": {
            "all": "allen Nodes",
            "selected": "ausgewählten Nodes"
        }
    },
    "status": {
        "status": "status: Alle",
        "statusNodes": "status: __number__",
        "label": {
            "source": "Status melden von",
            "sortByType": "Nach Typ sortieren"
        },
        "scope": {
            "all": "allen Nodes",
            "selected": "ausgewählten Nodes"
        }
    },
    "complete": {
        "completeNodes": "complete: __number__"
    },
    "debug": {
        "output": "Ausgabe",
        "status": "Status",
        "none": "Keine",
        "invalid-exp": "Ungültiger JSONata-Ausdruck: __error__",
        "msgprop": "Nachrichteneigenschaft",
        "msgobj": "Kompletten Nachrichten-Objekt",
        "autostatus": "Identisch mit Debug-Ausgabe",
        "to": "über",
        "debtab": "Debug-Tab",
        "tabcon": "Debug-Tab und Systemkonsole",
        "toSidebar": "Debug-Tab",
        "toConsole": "Systemkonsole",
        "toStatus": "Node-Status (max. 32 Zeichen)",
        "severity": "Stufe",
        "notification": {
            "activated": "Erfolgreich aktiviert: __label__",
            "deactivated": "Erfolgreich deaktiviert: __label__"
        },
        "sidebar": {
            "label": "Debug",
            "name": "Debug-Nachrichten",
            "filterAll": "Alle Nodes/Flows",
            "filterSelected": "Ausgewählte Nodes",
            "filterCurrent": "Aktueller Flow",
            "debugNodes": "Debug-Nodes",
            "clearLog": "Debug-Protokoll löschen",
            "filterLog": "Debug-Protokoll filtern",
            "openWindow": "In neuem Fenster öffnen",
            "copyPath": "Pfad kopieren",
            "copyPayload": "Wert kopieren",
            "pinPath": "Angezeigt lassen (pinnen)"
        },
        "messageMenu": {
            "collapseAll": "Alle Pfade ausblenden",
            "clearPinned": "Gepinnte Anzeige rücksetzen",
            "filterNode": "Diesen Node filtern",
            "clearFilter": "Filter rücksetzen"
        }
    },
    "link": {
        "linkIn": "Eingehende Verbindung",
        "linkOut": "Ausgehende Verbindung"
    },
    "tls": {
        "tls": "TLS-Konfiguration",
        "label": {
            "use-local-files": "Schlüssel und Zertifikate aus lokalen Dateien verwenden",
            "upload": "Hochladen",
            "cert": "Zertifikat",
            "key": "Privater Schlüssel",
            "passphrase": "Passphrase",
            "ca": "CA-Zertifikat",
            "verify-server-cert": "Server-Zertifikat überprüfen",
            "servername": "Server-Name"
        },
        "placeholder": {
            "cert": "Pfad zu Zertifikat (PEM-Format)",
            "key": "Pfad zum privaten Schlüssel (PEM-Format)",
            "ca": "Pfad zu CA-Zertifikat (PEM-Format)",
            "passphrase": "Passphrase des privaten Schlüssels (optional)",
            "servername": "Zur Verwendung mit SNI"
        },
        "error": {
            "missing-file": "Keine Zertifikats-/Schlüsseldatei angegeben"
        }
    },
    "exec": {
        "exec": "exec",
        "spawn": "spawn",
        "label": {
            "command": "Befehl",
            "append": "Anhängen",
            "timeout": "Zeitlimit",
            "timeoutplace": "optional",
            "return": "Ausgabe",
            "seconds": "Sekunden",
            "stdout": "Standardausgabe (stdout)",
            "stderr": "Standardfehlerausgabe (stderr)",
            "retcode": "Rückgabe-Code"
        },
        "placeholder": {
            "extraparams": "Zusätzliche Übergabeparameter"
        },
        "opt": {
            "exec": "nach Befehlsabschluss (exec)",
            "spawn": "während Befehlausführung (spawn)"
        },
        "oldrc": "Alter Ausgabestil (Kompatibilitätsmodus)"
    },
    "function": {
        "function": "",
        "label": {
            "setup": "Setup",
            "function": "Funktion",
            "initialize": "Start",
            "finalize": "Stopp",
            "outputs": "Ausgänge",
            "modules": "Module"
        },
        "text": {
            "initialize": "// Der Code hier wird ausgeführt,\n// wenn der Node gestartet wird\n",
            "finalize": "// Der Code hier wird ausgeführt,\n// wenn der Node gestoppt wird\n"
        },
        "require": {
            "var": "Variable",
            "module": "Modul"
        },
        "error": {
            "moduleNotAllowed": "Modul __module__ nicht erlaubt",
            "moduleLoadError": "Fehler beim Laden des Moduls __module__: __error__",
            "moduleNameError": "Ungültiger Modul-Variablenname: __name__",
            "moduleNameReserved": "Reservierter Variablenname: __name__",
            "inputListener": "Es kann keine Überwachung (listener) von 'input'-Ereignissen innerhalb der Funktion hinzugefügt werden",
            "non-message-returned": "Function hat versucht, eine Nachricht vom Typ __type__ zu senden"
        }
    },
    "template": {
        "template": "template",
        "label": {
            "template": "Vorlage",
            "property": "Eigenschaft",
            "format": "Syntaxhervorhebung",
            "syntax": "Format",
            "output": "Ausgabe als",
            "mustache": "Mustache-Vorlage",
            "plain": "Klartext",
            "json": "Parsed JSON",
            "yaml": "Parsed YAML",
            "none": "keine"
        },
        "templatevalue": "Dies sind die Nutzdaten (Payload): { { payload } }!"
    },
    "delay": {
        "action": "Aktion",
        "for": "Um",
        "delaymsg": "Jede Nachricht verzögern",
        "delayfixed": "Fixe Verzögerung",
        "delayvarmsg": "Verzög. mit msg.delay überschreiben",
        "randomdelay": "Zufällige Verzögerung",
        "limitrate": "Nachrichtenrate begrenzen",
        "limitall": "Alle Nachrichten",
        "limittopic": "Für jedes msg.topic",
        "fairqueue": "Jedes Topic der Reihe nach",
        "timedqueue": "Alle Topics senden",
        "milisecs": "Milisekunden",
        "secs": "Sekunden",
        "sec": "Sekunde",
        "mins": "Minuten",
        "min": "Minute",
        "hours": "Stunden",
        "hour": "Stunde",
        "days": "Tage",
        "day": "Tag",
        "between": "Zwischen",
        "and": "&",
        "rate": "Rate",
        "msgper": "msg(s) pro",
        "dropmsg": "Zwischennachrichten löschen",
        "label": {
            "delay": "Verzögerung",
            "variable": "Variable",
            "limit": "Begrenzung",
            "limitTopic": "Begrenzung Topic",
            "random": "Zufall",
            "units": {
                "second": {
                    "plural": "Sekunden",
                    "singular": "Sekunde"
                },
                "minute": {
                    "plural": "Minuten",
                    "singular": "Minute"
                },
                "hour": {
                    "plural": "Stunden",
                    "singular": "Stunde"
                },
                "day": {
                    "plural": "Tage",
                    "singular": "Tag"
                }
            }
        },
        "error": {
            "buffer": "Puffer enthält mehr als 1.000 Nachrichten",
            "buffer1": "Puffer enthält mehr als 10.000 Nachrichten"
        }
    },
    "trigger": {
        "send": "Sende",
        "then": "dann",
        "then-send": "dann sende",
        "output": {
            "string": "die Zeichenfolge",
            "number": "die Zahl",
            "existing": "vorhandenes Nachrichtenobjekt",
            "original": "originales Nachrichtenobjekt",
            "latest": "letztes Nachrichtenobjekt",
            "nothing": "nichts"
        },
        "wait-reset": "warten auf Rücksetzung (Block)",
        "wait-for": "warte für",
        "wait-loop": "sende erneut alle",
        "for": "Behandlung",
        "bytopics": "jede",
        "alltopics": "alle Nachrichten",
        "duration": {
            "ms": "Millisekunden",
            "s": "Sekunden",
            "m": "Minuten",
            "h": "Stunden"
        },
        "extend": "Verzögerung verlängern bei Eingang neuer Nachrichten",
        "override": "Verzögerung mit msg.delay überschreiben",
        "second": "Sende zweite Nachricht über separaten Ausgang",
        "label": {
            "trigger": "Trigger",
            "trigger-block": "Trigger & Block",
            "trigger-loop": "erneut senden alle",
            "reset": "Trigger wird rückgesetzt durch:",
            "resetMessage": "msg.reset ist gesetzt",
            "resetPayload": "msg.payload ist gleich",
            "resetprompt": "optional"
        }
    },
    "comment": {
        "comment": "comment"
    },
    "unknown": {
        "label": {
            "unknown": "Unbekannt"
        },
        "tip": "<p>Dieser Node ist ein Typ, der Ihrer Node-RED-Installation unbekannt ist.</p><p><i>Wenn Sie den Node in diesem Zustand übernehmen (deploy), wird die Konfiguration beibehalten, aber der Flow wird erst gestartet, wenn der fehlende Node-Typ installiert ist.</i></p><p>Weitere Hilfe-Informationen finden Sie in der Info-Seitenleiste.</p>"
    },
    "mqtt": {
        "label": {
            "broker": "Server",
            "example": "z.B. lokaler Host",
            "output": "Ausgang",
            "qos": "QoS",
            "retain": "Retain",
            "clientid": "Client-ID",
            "port": "Port",
            "keepalive": "Keep-Alive",
            "cleansession": "Bereinigte Sitzung (clean session) verwenden",
            "cleanstart": "Verwende bereinigten Start",
            "use-tls": "Sichere Verbindung (SSL/TLS) verwenden",
            "tls-config": "TLS-Konfiguration",
            "verify-server-cert": "Server-Zertifikat überprüfen",
            "compatmode": "MQTT 3.1 unterstützen",
            "userProperties": "Benutzereigenschaften",
            "subscriptionIdentifier": "Subscription ID",
            "flags": "Flags",
            "nl": "Keine Nachrichten vom diesem Client empfangen",
            "rap": "Retain-Flag behalten von originaler Veröffentlichung",
            "rh": "Behandlung aufbewahrter Nachrichten ",
            "rh0": "Aufbewahrte Nachrichten senden",
            "rh1": "Nur von neuen Abonnements senden",
            "rh2": "Nicht(s) senden",
            "responseTopic": "Antwort-Topic",
            "contentType": "Inhaltstyp",
            "correlationData": "Korrelationsdaten",
            "expiry": "Zeitablauf (s)",
            "sessionExpiry": "Session-Zeitablauf (s)",
            "topicAlias": "Alias",
            "payloadFormatIndicator": "Format",
            "payloadFormatIndicatorFalse": "Undefnierte Bytes (Standard)",
            "payloadFormatIndicatorTrue": "UTF-8 encodierte Nutzdaten",
            "protocolVersion": "Protokoll",
            "protocolVersion3": "MQTT V3.1 (legacy)",
            "protocolVersion4": "MQTT V3.1.1",
            "protocolVersion5": "MQTT V5",
            "topicAliasMaximum": "Alias Max",
            "maximumPacketSize": "Max. Packetgröße",
            "receiveMaximum": "Empfange Max.",
            "session": "Session",
            "delay": "Verzögerung"
        },
        "sections-label": {
            "birth-message": "Nachricht bei Verbindungsaufbau",
            "will-message": "Nachricht bei unerwarteten Verbindungsabbruch",
            "close-message": "Nachricht vor Verbindungsabbau"
        },
        "tabs-label": {
            "connection": "Verbindung",
            "security": "Sicherheit",
            "messages": "Nachrichten"
        },
        "placeholder": {
            "clientid": "Leer lassen für automatische Generierung",
            "clientid-nonclean": "Festzulegen bei non-clean sessions",
            "will-topic": "Keine Nachricht, wenn leer",
            "birth-topic": "Keine Nachricht, wenn leer",
            "close-topic": "Keine Nachricht, wenn leer"
        },
        "state": {
            "connected": "Verbindung zum Broker __broker__ aufgebaut",
            "disconnected": "Verbindung zum Broker __broker__ abgebaut",
            "connect-failed": "Verbindung zum Broker __broker__ konnte nicht hergestellt werden"
        },
        "retain": "Retain",
        "output": {
            "buffer": "Einen binären Buffer",
            "string": "Ein String",
            "base64": "Ein Base64-kodierter String",
            "auto": "Auto-Erkennung (string oder buffer)",
            "json": "Ein analysiertes (parsed) JSON-Objekt"
        },
        "true": "wahr",
        "false": "falsch",
        "tip": "Tipp: Topic, QoS oder Retain leer lassen, um diese über die msg-Eigenschaften festzulegen",
        "errors": {
            "not-defined": "Topic nicht definiert",
            "missing-config": "Fehlende Broker-Konfiguration",
            "invalid-topic": "Ungültiges Topic angegeben",
            "nonclean-missingclientid": "Keine Client-ID angegeben. Bereinigte Sitzung (clean session) wird verwendet.",
            "invalid-json-string": "Ungültiger JSON-String",
            "invalid-json-parse": "Analyse des JSON-Strings fehlgeschlagen"
        }
    },
    "httpin": {
        "label": {
            "method": "Methode",
            "url": "URL",
            "doc": "Docs",
            "return": "Rückgabe",
            "upload": "Dateiuploads akzeptieren",
            "status": "Statuscode",
            "headers": "Kopfzeilen",
            "other": "andere",
            "paytoqs": {
                "ignore": "Ignorieren",
                "query": "Anfügen an query-string-Parameter",
                "body": "Senden als request-body"
            },
            "utf8String": "UTF-8-String",
            "binaryBuffer": "Binärer Buffer",
            "jsonObject": "Parsed JSON-Objekt",
            "authType": "Typ",
            "bearerToken": "Token"
        },
        "setby": "Duch msg.method festgelegt",
        "basicauth": "Basis-Authentifizierung verwenden",
        "use-tls": "Sichere Verbindung (SSL/TLS) aktivieren",
        "tls-config": "TLS-Konfiguration",
        "basic": "Basic-Authentifizierung",
        "digest": "Digest-Authentifizierung",
        "bearer": "Bearer-Authentifizierung",
        "use-proxy": "Proxy verwenden",
        "persist": "Verbindung aufrecht erhalten (keep-alive)",
        "proxy-config": "Proxy-Konfiguration",
        "use-proxyauth": "Proxy-Authentifizierung verwenden",
        "noproxy-hosts": "Hosts ignorieren",
        "utf8": "Eine UTF-8-Zeichenfolge",
        "binary": "Einen binären Buffer",
        "json": "Ein parsed JSON-Objekt",
        "tip": {
            "in": "Die URL ist relativ zu ",
            "res": "Die an diesen Node gesendeten Nachrichten <b>müssen</b> von einem <span style=\"background-color:Gainsboro\">http&nbsp;in</span>-Node stammen",
            "req": "Tipp: Wenn die JSON-Syntax-Analyse fehlschlägt, wird die abgerufene Zeichenfolge zurückgegeben, wie sie ist."
        },
        "httpreq": "http request",
        "errors": {
            "not-created": "<span style=\"background-color:Gainsboro\">http in</span>-Node kann nicht erstellt werden, wenn httpNodeRoot auf 'false' gesetzt ist.",
            "missing-path": "Fehlender Pfad",
            "no-response": "Kein Antwort-Objekt",
            "json-error": "JSON-Parse-Fehler",
            "no-url": "Keine URL angegeben",
            "deprecated-call": "Abgelehnter Aufruf von __method__",
            "invalid-transport": "Nicht-HTTP-Transport angefordert",
            "timeout-isnan": "Zeitlimit-Wert ignoriert, da keine gültige Zahl",
            "timeout-isnegative": "Zeitlimit-Wert ignoriert, da negative Zahl",
            "invalid-payload": "Üngültige Nutzdaten (Payload)"
        },
        "status": {
            "requesting": "Anfordernd"
        }
    },
    "websocket": {
        "label": {
            "type": "Typ",
            "path": "Pfad",
            "url": "URL"
        },
        "listenon": "Lauschen (listen on)",
        "connectto": "Verbinden mit",
        "sendrec": "Senden/ Empfangen",
        "payload": "Nutzdaten (Payload)",
        "message": "Gesamte Nachricht",
        "tip": {
            "path1": "Standardmäßig enthält <code>payload</code> die Daten, die über einen WebSocket gesendet oder von einem WebSocket empfangen werden. Der Empfänger (Listener) kann so konfiguriert werden, dass er das gesamte Nachrichtenobjekt als eine JSON-formatierte Zeichenfolge (string) sendet oder empfängt.",
            "path2": "Dieser Pfad ist relativ zu <code>__path__</code>.",
            "url1": "URL sollte ws:&#47;&#47; oder wss:&#47;&#47; Schema verwenden und auf einen vorhandenen WebSocket-Listener verweisen.",
            "url2": "Standardmäßig enthält <code>payload</code> die Daten, die über einen WebSocket gesendet oder von einem WebSocket empfangen werden. Der Client kann so konfiguriert werden, dass er das gesamte Nachrichtenobjekt als eine JSON-formatierte Zeichenfolge (string) sendet oder empfängt."
        },
        "status": {
            "connected": "Verbunden __count__",
            "connected_plural": "Verbunden __count__"
        },
        "errors": {
            "connect-error": "Fehler dei der WS-Verbindung: ",
            "send-error": "Fehler beim Senden: ",
            "missing-conf": "Fehlende Server-Konfiguration",
            "duplicate-path": "Keine zwei WebSocket-Empfänger (Listener) möglich mit dem gleichen Pfad: __path__"
        }
    },
    "watch": {
        "watch": "watch",
        "label": {
            "files": "Datei (en)",
            "recursive": "Unterverzeichnisse rekursiv überwachen"
        },
        "placeholder": {
            "files": "Kommagetrennte Datei- bzw. Verzeichnisliste"
        },
        "tip": "Unter Windows müssen doppelte Schrägstriche \\\\ in Verzeichnisnamen verwendet werden"
    },
    "tcpin": {
        "label": {
            "type": "Typ",
            "output": "Ausgang",
            "port": "Port",
            "host": "Host",
            "payload": "Nutzdaten (Payload)",
            "delimited": "Begrenzt durch",
            "close-connection": "Verbindung nach jeder gesendeten Nachricht schließen",
            "decode-base64": "Base64-Nachricht dekodieren",
            "server": "Server",
            "return": "Rückkehr",
            "ms": "ms",
            "chars": "Zeichen"
        },
        "type": {
            "listen": "Lauschen an",
            "connect": "Verbinden mit",
            "reply": "Auf TCP antworten"
        },
        "output": {
            "stream": "Strom von",
            "single": "Einzelne",
            "buffer": "Buffer",
            "string": "Strings",
            "base64": "Base64-Strings"
        },
        "return": {
            "timeout": "nach festen Zeitlimit von",
            "character": "bei Empfang des Zeichens",
            "number": "nach fester Zeichenanzahl von",
            "never": "niemals - Verbindung wird gehalten",
            "immed": "sofort - Antwort wird nicht abgewartet"
        },
        "status": {
            "connecting": "Verbinde mit __host__:__port__",
            "connected": "Verbunden mit __host__:__port__",
            "listening-port": "Empfangsbereit an Port __port__",
            "stopped-listening": "Empfangsbereitschaft gestoppt an Port",
            "connection-from": "Verbindung von __host__:__port__",
            "connection-closed": "Verbindung geschlossen von __host__:__port__",
            "connections": "__count__ Verbindung ",
            "connections_plural": "__count__ Verbindungen"

        },
        "errors": {
            "connection-lost": "Verbindung verloren zu __host__:__port__",
            "timeout": "Aufgrund Zeitüberschreitung geschlossener Port __port__",
            "cannot-listen": "Port __port__ kann nicht empfangsbereit gesetzt werden. FEHLER: __error__",
            "error": "FEHLER: __error__",

            "socket-error": "Socket-Fehler von __host__:__port__",
            "no-host": "Host und/oder Port nicht vorgegeben",
            "connect-timeout": "Verbindungs-Zeitüberschreitung",
            "connect-fail": "Verbindung fehlgeschlagen"
        }
    },
    "udp": {
        "label": {
            "listen": "Empfang von",
            "onport": "Port",
            "using": "Protokoll",
            "output": "Ausgabe",
            "group": "Gruppe",
            "interface": "Lokal-IF",
            "send": "Senden von",
            "toport": "Port",
            "address": "Adresse",
            "decode-base64": "Dekodierung Base64-kodierter Nutzdaten (Payload)"
        },
        "placeholder": {
            "interface": "(optional) lokale Schnittstelle oder Adresse",
            "interfaceprompt": "(optional) lokale Schnittstelle oder Adresse",
            "address": "Ziel-IP"
        },
        "udpmsgs": "UDP-Nachrichten",
        "mcmsgs": "Multicast-Nachrichten",
        "udpmsg": "UDP-Nachricht",
        "bcmsg": "Broadcast-Nachricht",
        "mcmsg": "Multicast-Nachricht",
        "output": {
            "buffer": "Ein binärer Buffer",
            "string": "Ein String",
            "base64": "Ein Base64-kodierter String"
        },
        "bind": {
            "random": "Bindung an zufälligen lokalen Port",
            "local": "Bindung an lokalen Port",
            "target": "Bindung an Ziel-Port"
        },
        "tip": {
            "in": "Tipp: Stellen Sie sicher, dass Ihre Firewall die eingehende Verbindung zulässt",
            "out": "Tipp: Lassen Sie Adresse- und Port-Angabe leer, wenn Sie diese mit <code>msg.ip</code> und <code>msg.port</code> vorgeben möchten",
            "port": "Bereits verwendete Ports: "
        },
        "status": {
            "listener-at": "UDP-Empfangsbereitschaft bei __host__:__port__",
            "mc-group": "UDP-Multicast-Gruppe __group__",
            "listener-stopped": "UDP-Empfangsbereitschaft gestoppt",
            "output-stopped": "UDP-Ausgabe gestoppt",
            "mc-ready": "UDP-Multicast bereit: __iface__: __outport__-> __host__:__port__",
            "bc-ready": "UDP-Broadcast bereit: __outport__-> __host__:__port__",
            "ready": "UDP bereit: __outport__-> __host__:__port__",
            "ready-nolocal": "UDP bereit: __host__:__port__",
            "re-use": "UDP Wiederverwendung Socket: __outport__-> __host__:__port__"
        },
        "errors": {
            "access-error": "UDP-Zugriffsfehler, Sie benötigen möglicherweise Root-Zugriff für Ports unter 1024",
            "error": "FEHLER: __error__",
            "bad-mcaddress": "Ungültige Multicast-Adresse",
            "interface": "Muss IP-Adresse der erforderlichen Schnittstelle sein",
            "ip-notset": "UDP: IP-Adresse nicht angegeben",
            "port-notset": "UDP: Port nicht angegeben",
            "port-invalid": "UDP: Port-Nummer ungültig",
            "alreadyused": "UDP: Port __port__ bereits in Verwendung",
            "ifnotfound": "UDP: Interface __iface__ nicht gefunden"
        }
    },
    "switch": {
        "switch": "switch",
        "label": {
            "property": "Eigenschaft",
            "rule": "Regel",
            "repair": "Nachrichtensequenzen erzeugen"
        },
        "previous": "Vorheriger Wert",
        "and": "und",
        "checkall": "Alle Regeln abarbeiten",
        "stopfirst": "Nach erster Regel-Übereinstimmung stoppen",
        "ignorecase": "Groß-/Kleinschreibung ignorieren",
        "rules": {
            "btwn": "liegt zwischen",
            "cont": "enthält",
            "regex": "Regulärer Ausdruck",
            "true": "ist true",
            "false": "ist false",
            "null": "ist null",
            "nnull": "ist nicht null",
            "istype": "ist vom Typ",
            "empty": "ist leer",
            "nempty": "ist nicht leer",
            "head": "Anfang",
            "tail": "Ende",
            "index": "Index zwischen",
            "exp": "JSONata-Ausdruck",
            "else": "ansonsten",
            "hask": "hat Schlüssel"
        },
        "errors": {
            "invalid-expr": "Ungültiger JSONata-Ausdruck: __error__",
            "too-many": "Zu viele anstehende Nachrichten im <span style=\"background-color:Gainsboro\">switch</span>-Node"
        }
    },
    "change": {
        "label": {
            "rules": "Regeln",
            "rule": "Regel",
            "set": "setze __property__",
            "change": "__property__ ändern",
            "delete": "__property__ löschen",
            "move": "bewege __property__",
            "changeCount": "change: __count__ Regeln",
            "regex": "Reguläre Ausdrücke verwenden"
        },
        "action": {
            "set": "Setze",
            "change": "Ändere",
            "delete": "Lösche",
            "move": "Verschiebe",
            "to": "auf/nach",
            "search": "Suche nach",
            "replace": "Ersetze durch"
        },
        "errors": {
            "invalid-from": "Ungültiges 'from' Merkmal: __error__",
            "invalid-json": "Ungültiges 'to' JSON Merkmal",
            "invalid-expr": "Ungültiger JSONata Ausdruck: __error__",
            "no-override": "Cannot set property of non-object type: __property__"
        }
    },
    "range": {
        "range": "range",
        "label": {
            "action": "Modus",
            "inputrange": "Eingangswertebereich",
            "resultrange": "Ausgangswertebereich",
            "from": "von",
            "to": "bis",
            "roundresult": "Runde Ergebnis auf die nächste ganze Zahl"
        },
        "placeholder": {
            "min": "z.B. 0",
            "maxin": "z.B. 99",
            "maxout": "z.B. 255"
        },
        "scale": {
            "payload": "Skalierung",
            "limit": "Skalierung und Begrenzung",
            "wrap": "Skalieren und Begrenzung mit Überlauf"
        },
        "tip": "Tipp: Dieser Node funktioniert NUR mit Zahlenwerten.",
        "errors": {
            "notnumber": "Keine Zahl"
        }
    },
    "csv": {
        "label": {
            "columns": "Spalten",
            "separator": "Trennzeichen",
            "c2o": "Optionen CSV zu Objekt",
            "o2c": "Optionen Objekt zu CSV",
            "input": "Eingang",
            "skip-s": "Überspringe erste",
            "skip-e": "Zeile(n)",
            "firstrow": "Erste Zeile enthält Spaltennamen",
            "output": "Ausgang",
            "includerow": "Spaltennamenszeile einschließen",
            "newline": "Zeilenvorschub",
            "usestrings": "Zahlenwerte ermitteln",
            "include_empty_strings": "Leere Zeichenfolgen (string) einbeziehen",
            "include_null_values": "Nullwerte einbeziehen"
        },
        "placeholder": {
            "columns": "Durch Kommas getrennte Spaltennamen"
        },
        "separator": {
            "comma": "Komma",
            "tab": "Tab",
            "space": "Leerzeichen",
            "semicolon": "Semikolon",
            "colon": "Doppelpunkt",
            "hashtag": "Raute",
            "other": "Sonstiges"
        },
        "output": {
            "row": "Eine Nachricht pro Zeile",
            "array": "Eine einzige Nachricht (array)"
        },
        "newline": {
            "linux": "Linux (\\n)",
            "mac": "Mac (\\r)",
            "windows": "Windows (\\r\\n)"
        },
        "hdrout": {
            "none": "Spaltennamen niemals senden",
            "all": "Spaltennamen immer senden",
            "once": "Spaltennamen einmal senden bis msg.reset"
        },
        "errors": {
            "csv_js": "Dieser Node verarbeitet nur CSV-Zeichenfolgen oder JS-Objekte",
            "obj_csv": "Es wurde keine Spaltennamen für Objekt/CSV-Wandlung angegeben",
            "bad_csv": "Unförmige CSV-Daten - Ausgangsdaten möglicherweise korrupt"
        }
    },
    "html": {
        "label": {
            "select": "Selektor",
            "output": "Ausgang",
            "in": "in"
        },
        "output": {
            "html": "HTML-Inhalt der Elemente",
            "text": "Nur Textinhalt der Elemente",
            "attr": "Objekt mit allen Elemente-Attributen"
        },
        "format": {
            "single": "Eine Nachricht mit einem Array",
            "multi": "Einzelne Nachrichten je Element"
        }
    },
    "json": {
        "errors": {
            "dropped-object": "Nicht-Objekt-Nutzdaten (Payload) ignoriert",
            "dropped": "Nicht unterstützte Nutzdatentyp (Payload) ignoriert",
            "dropped-error": "Fehler beim Konvertieren der Nutzdaten (Payload)",
            "schema-error": "JSON-Schema-Fehler",
            "schema-error-compile": "JSON-Schema-Fehler: Schema konnte nicht kompiliert werden"
        },
        "label": {
            "o2j": "Optionen Objekt => JSON",
            "pretty": "JSON-Zeichenfolge formatieren",
            "action": "Aktion",
            "property": "Eigenschaft",
            "actions": {
                "toggle": "Konvertierung JSON-String <=> JS-Objekt",
                "str": "Konvertierung zu JSON-Zeichenfolge",
                "obj": "Konvertierung zu JavaScript-Objekt"
            }
        }
    },
    "yaml": {
        "errors": {
            "dropped-object": "Nicht-Objekt-Nutzdaten (Payload) ignoriert",
            "dropped": "Nicht unterstützte Nutzdatentyp (Payload) ignoriert",
            "dropped-error": "Fehler beim Konvertieren der Nutzdaten (Payload)"
        }
    },
    "xml": {
        "label": {
            "represent": "Eigenschaftsname für XML-Tag-Attribute",
            "prefix": "Eigenschaftsname für Tag-Textinhalt",
            "advanced": "Erweiterte Optionen",
            "x2o": "Optionen XML zu Objekt"
        },
        "errors": {
            "xml_js": "Dieser Node verarbeitet nur XML-Zeichenfolgen oder JS-Objekte."
        }
    },
    "file": {
        "label": {
            "filename": "Dateiname",
            "action": "Aktion",
            "addnewline": "Zeilenumbruch (\\n) zu jeden Nutzdaten (Payload) hinzufügen",
            "createdir": "Verzeichnis erstellen, wenn nicht vorhanden",
            "outputas": "Ausgabe",
            "breakchunks": "In Chunks aufteilen",
            "breaklines": "In Linien aufteilen",
            "filelabel": "file",
            "sendError": "Nachricht bei Fehler senden (herkömmlicher Modus)",
            "encoding": "Kodierung",
            "deletelabel": "lösche __file__",
            "utf8String": "UTF-8-String",
            "binaryBuffer": "Binärer Buffer"
        },
        "action": {
            "append": "an Datei anhängen",
            "overwrite": "Datei überschreiben",
            "delete": "Datei löschen"
        },
        "output": {
            "utf8": "Einzelne UTF-8-Zeichenfolge",
            "buffer": "Einzelnes Buffer-Objekt",
            "lines": "Eine Nachricht je Zeile",
            "stream": "Datenstrom von binären Buffern"
        },
        "status": {
            "wrotefile": "In Datei geschrieben: __file__",
            "deletedfile": "Datei gelöscht: __file__",
            "appendedfile": "An Datei angehängt: __file__"
        },
        "encoding": {
            "none": "Standard (default)",
            "native": "Native",
            "unicode": "Unicode",
            "japanese": "Japanisch",
            "chinese": "Chinesisch",
            "korean": "Koreanisch",
            "taiwan": "Taiwan/Hong Kong",
            "windows": "Windows codepages",
            "iso": "ISO Codeseiten",
            "ibm": "IBM Codeseiten",
            "mac": "Mac Codeseiten",
            "koi8": "KOI8 Codeseiten",
            "misc": "Sonstige"
        },
        "errors": {
            "nofilename": "Kein Dateiname angegeben",
            "invaliddelete": "Warnung: Ungültiges Löschen. Bitte verwenden Sie im Konfigurationsdialog eine bestimmte Löschoption.",
            "deletefail": "Fehler beim Löschen der Datei: __error__",
            "writefail": "Fehler beim Schreiben in Datei: __error__",
            "appendfail": "Fehler beim Anhängen an Datei: __error__",
            "createfail": "Fehler beim Erstellen der Datei: __error__"
        },
        "tip": "Tipp: Der Dateiname sollte ein absoluter Pfad sein. Andernfalls wird er relativ zum Arbeitsverzeichnis des Node-RED-Prozesses angewandt."
    },
    "split": {
        "split": "split",
        "intro": "Aufteilung von <code>msg.payload</code> entsprechend dem Typ:",
        "object": "<b>object</b>",
        "objectSend": "Sende eine Nachricht für jedes Schlüssel/Wert-Paar",
        "strBuff": "<b>string</b> / <b>buffer</b>",
        "array": "<b>array</b>",
        "splitUsing": "Aufteilung",
        "splitLength": "feste Längen von",
        "stream": "Als Nachrichtenstrom behandeln (Streaming-Modus)",
        "addname": " Schlüssel kopieren zu"
    },
    "join": {
        "join": "join",
        "mode": {
            "mode": "Modus",
            "auto": "Automatisch",
            "merge": "Sequenzen zusammenführen",
            "reduce": "Sequenz reduzieren",
            "custom": "Manuell"
        },
        "combine": "Verbinde jede",
        "completeMessage": "vollständige Nachricht",
        "create": "und erstelle",
        "type": {
            "string": "ein String",
            "array": "ein Array",
            "buffer": "einen binären Buffer",
            "object": "ein Schlüssel/Wert-Objekt",
            "merged": "ein zusammengeführtes Objekt"
        },
        "using": "mit dem Wert von",
        "key": "als Schlüssel",
        "joinedUsing": "verbunden mit",
        "send": "Senden der Nachricht:",
        "afterCount": "Nach einer Anzahl von Nachrichtenteilen",
        "count": "Anzahl",
        "subsequent": "und bei jeder nachfolgenden Nachricht",
        "afterTimeout": "Bei Zeitablauf nach erster Nachricht von",
        "seconds": "Sekunden",
        "complete": "Nach Nachricht mit <code>msg.complete</code>-Eigenschaft",
        "tip": "Dieser Modus setzt voraus, dass dieser Node entweder mit einem <span style=\"background-color:Gainsboro\">split</span>-Node kombiniert ist oder dass die empfangenen Nachrichten über eine ordnungsgemäß konfigurierte <code>msg.parts</code>-Eigenschaft verfügen.",
        "too-many": "Zu viele anstehende Nachrichten im <span style=\"background-color:Gainsboro\">join</span>-Node",
        "merge": {
            "topics-label": "Zusammengeführte Topics",
            "topics": "Topics",
            "topic": "Topic",
            "on-change": "Sende Zusammenführungs-Nachricht bei Ankunft eines neuen Topics"
        },
        "reduce": {
            "exp": "Reduktions-Ausdruck",
            "exp-value": "Ausdruck",
            "init": "Anfangswert",
            "right": "In umgekehrter Reihenfolge auswerten (von letzten zu ersten)",
            "fixup": "Fix-up-Ausdruck"
        },
        "errors": {
            "invalid-expr": "Ungültiger JSONata-Ausdruck: __error__",
            "invalid-type": "Zusammenführung von __error__ zu buffer nicht möglich"
        }
    },
    "sort": {
        "sort": "sort",
        "target": "Sortierung",
        "seq": "Nachrichtensequenz",
        "key": "Schlüssel",
        "elem": "Elementwert",
        "order": "Reihenfolge",
        "ascending": "aufsteigend",
        "descending": "absteigend",
        "as-number": "als Zahlenwert",
        "invalid-exp": "Ungültiger JSONata-Ausdruck in <span style=\"background-color:Gainsboro\">sort</span>-Node: __message__",
        "too-many": "Zu viele anstehende Nachrichten in <span style=\"background-color:Gainsboro\">sort</span>-Node",
        "clear": "Anstehende Nachricht in <span style=\"background-color:Gainsboro\">sort</span>-Node löschen"
    },
    "batch": {
        "batch": "batch",
        "mode": {
            "label": "Modus",
            "num-msgs": "Gruppierung anhand Nachrichtenanzahl",
            "interval": "Gruppierung anhand Zeitintervall",
            "concat": "Verknüpfung von Sequenzen"
        },
        "count": {
            "label": "Nachrichtenanzahl",
            "overlap": "Überlappung",
            "count": "Anzahl",
            "invalid": "Ungültige Anzahl und Überlappung"
        },
        "interval": {
            "label": "Intervall",
            "seconds": "Sekunden",
            "empty": "Leere Nachricht senden, wenn keine Nachricht eingeht"
        },
        "concat": {
            "topics-label": "Topics",
            "topic": "Topic"
        },
        "too-many": "Zu viele anstehende Nachrichten im <span style=\"background-color:Gainsboro\">batch</span>-Node",
        "unexpected": "Unerwarteter Modus",
        "no-parts": "Keine parts-Eigenschaft in Nachricht"
    },
    "rbe": {
        "rbe": "filter",
        "label": {
            "func": "Modus",
            "init": "Sende Anfangswert",
            "start": "Startwert",
            "name": "Name",
            "septopics": "Modus für jedes msg.topic separat anwenden"
        },
        "placeholder":{
            "bandgap": "z.B. 10 oder 5%",
            "start": "Leer lassen, um erste empfangenen Daten zu nutzen"
        },
        "opts": {
            "rbe": "Blockieren bis Wertänderung",
            "rbei": "Blockieren bis Wertänderung (Anfangswert ignorieren)",
            "deadband": "Blockieren bis Wertänderung ist größer als",
            "deadbandEq": "Blockieren bis Wertänderung ist größer-gleich",
            "narrowband": "Blockieren wenn Wertänderung ist größer als",
            "narrowbandEq": "Blockieren wenn Wertänderung ist größer-gleich",
            "in": "verglichen mit letzten Eingangswert",
            "out": "verglichen mit letzten gültigen Ausgangswert"
        },
        "warn": {
            "nonumber": "Keine Zahl gefunden in den Nutzdaten (Payload)"
        }
    }
}
